#!/usr/bin/env ruby
require 'gli'

begin # XXX: Remove this begin/rescue before distributing your app

  require 'draw'
  require 'rainbow/ext/string'
  require 'highline/import'
  require 'pstore'
  require 'cucumber'
  require 'terminal-table'

rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/draw` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/draw now"
  exit 64
end

include GLI::App

program_desc 'This app lets you build a list of guests and run a gift draw from this list'

version Draw::VERSION

subcommand_option_handling :normal
arguments :strict

# Fill this array with ["Name", "Joint"] separated items
# In case seed file is not available
GUESTS = []

desc 'Clears the gifts list'
command :clear do |c|
  c.action do |global_options,options,args|
    begin
      guests = []
      @store.transaction do
        guests = @store[:guests] || []
      end
      if guests
        guests.each do |guest|
          guest.recipient = nil
        end
        print_guests guests
      else
        puts "The list of guests is empty ..."
      end
    rescue Exception => e
      puts "draw::clear \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Lists all gifts (can be filtered by name)'
arg_name 'name'
command :list do |c|
  c.desc 'Show the gifts from/to list'

  c.action do |global_options,options,args|
    begin
      keyword = args[0] unless args.nil?
      gifts = []
      @store.transaction do
        gifts = @store[:gifts] || []
      end

      gifts = keyword.nil? ? gifts : gifts.select {|g| g.from.downcase.include? keyword.downcase }
      if gifts.nil? || gifts.length == 0
        if keyword
          puts "No gift match the query: " + keyword
        else
          puts "The list of gifts is empty ..."
        end
      end
      print_gifts gifts
    rescue Exception => e
      puts "draw::list \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Run the draw and display gifts from/to list'
command :run do |c|
  c.action do |global_options,options,args|
    begin
      guests = []
      @store.transaction do
        guests = @store[:guests] || []
      end

      gifts = []
      if guests
        recipients = guests.map { |g| g.name }
        guests.each do |guest|
          recipient = guest.name
          while recipients.count > 0 && (guest.name == recipient || guest.joint == recipient)
            recipient = recipients.shuffle.sample
          end
          from = guest.joint.nil? ? guest.name : "#{guest.name}" + " / (#{guest.joint})"
          gift = Gift.new(from, recipient)
          gifts << gift
          # Remove recipient from recipients array
          recipients.reject! {|x| x == recipient }
        end
        puts gifts.inspect
        @store.transaction do
          @store[:gifts] = gifts
        end
      else
        puts "The list of gifts is empty ..."
      end
      print_gifts gifts
    rescue Exception => e
      puts "draw::run \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Guests namespace'
command :guests do |c|

  c.desc 'Add a new guest to the list'
  c.command :add do |a|
    a.desc 'Guest Name'
    a.flag [:n, :name], required: true
    a.desc 'Guest Spouse/Friend Name'
    a.flag [:j, :joint]

    a.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          guests = @store[:guests] | []
        end
        values = [options[:name], options[:joint]]

        add = (guests.length > 0 && guests.select {|g| g.name.downcase.include? options[:name].downcase }.length > 0) ? false : true

        if add
          guest = Guest.new(options[:name], options[:joint])
          @store.transaction do
            @store[:guests] << guest
            if @store[:guests].include? guest
              puts "Successfully added " + guest.name + " to the list of guests"
              guests << guest
            end
          end
        else
          name = options[:name].color :red
          puts "Guest '" + name + "' is already in the list"
        end
        print_guests guests
      rescue Exception => e
        puts "draw::guests::add \t ERROR:\t #{e.message}"
      end
    end
  end

  c.desc 'Delete all guests in the list'
  c.command :clear do |a|
    a.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          @store[:guests] = []
          guests = @store[:guests]
        end
        puts "Successfully deleted all guests" if guests.length == 0
        print_guests guests
      rescue Exception => e
        puts "draw::guests::clear \t ERROR:\t #{e.message}"
      end
    end
  end

  c.desc 'Lists all guests'
  c.arg_name 'name'
  c.command :list do |a|
    a.action do |global_options,options,args|
      begin
        keyword = args[0] unless args.nil?
        guests = []
        @store.transaction do
          guests = @store[:guests] || []
        end

        guests = keyword.nil? ? guests : guests.select {|g| g.name.downcase.include? keyword.downcase }
        if guests.nil? || guests.length == 0
          if keyword
            puts "No guest match the query: " + keyword
          else
            puts "The list of guests is empty ..."
          end
        end
        print_guests guests
      rescue Exception => e
        puts "draw::guests::list \t ERROR:\t #{e.message}"
      end
    end
  end

  c.desc 'Match all guests'
  c.command :match do |a|
    a.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          guests = @store[:guests] || []
        end
        guests.each do |guest|
          if guest.joint
            add = (guests.length > 0 && guests.select {|g| g.name.downcase.include? guest.joint.downcase }.length > 0) ? false : true
            if add
              new_guest = Guest.new(guest.joint, guest.name)
              @store.transaction do
                @store[:guests] << new_guest
                if @store[:guests].include? new_guest
                  puts "Successfully added " + new_guest.name + " to the list of guests"
                  guests << new_guest
                end
              end
            end
          end
        end
        print_guests guests
      rescue Exception => e
        puts "draw::guests::match \t ERROR:\t #{e.message}"
      end
    end
  end

  c.desc 'Seed guests list'
  c.command :seed do |a|
    a.action do |global_options,options,args|
      begin
        new_guests = GUESTS || load_seed()
        guests = []
        @store.transaction do
          guests = @store[:guests] || []
        end
        new_guests.each do |new_guest|
          guest = Guest.new(new_guest[0], new_guest[1])
          add = (guests.length > 0 && guests.select {|g| g.name.downcase.include? guest.name.downcase }.length > 0) ? false : true
          if add
            @store.transaction do
              @store[:guests] << guest
              if @store[:guests].include? guest
                puts "Successfully added " + guest.name + " to the list of guests"
                guests << guest
              end
            end
          else
            name = new_guest[0].color :red
            puts "Guest '" + name + "' is already in the list"
          end
        end
        print_guests guests
      rescue Exception => e
        puts "draw::guests::seed \t ERROR:\t #{e.message}"
      end
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  @store = PStore.new %(#{ENV['HOME']}/draw.pstore)
  @store.transaction do
    @store[:guests] ||= []
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

private

def print_guests guests
  table = Terminal::Table.new do |t|
    t.style = { width: 80, border_x: "=", border_i: "+"}
    t.title = "Draw list of guests"
    t.headings = ["Index", "Guest", "Spouse/Friend"]

    index = 1
    guests.each_with_index do |guest, index|
      index += 1
      t << [index.to_s, guest.name, guest.joint]
    end
  end
  table.align_column 0, :center
  puts table
end

def print_gifts gifts
  table = Terminal::Table.new do |t|
    t.style = { width: 80, border_x: "=", border_i: "+"}
    t.title = "Draw list of gifts"
    t.headings = ["Index", "From", "To"]

    index = 1
    gifts.each_with_index do |gift, index|
      index += 1
      t << [index.to_s, gift.from, gift.to]
    end
  end
  table.align_column 0, :center
  puts table
end

def load_seed
  guests = []
  line_num = 0
  text = File.open('guests.txt').read
  text.gsub!(/\r\n?/, "\n")
  text.each_line do |line|
    values = line.split(",")
    guests << [values[0].strip(), values[1].strip()]
  end
  return guests
end

exit run(ARGV)
