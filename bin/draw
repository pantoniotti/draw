#!/usr/bin/env ruby
require 'gli'

begin # XXX: Remove this begin/rescue before distributing your app

  require 'draw'
  require 'rainbow/ext/string'
  require 'highline/import'
  require 'pstore'
  require 'cucumber'

rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/draw` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/draw now"
  exit 64
end

include GLI::App

program_desc 'Draw lets you create a list of guests and build a gifts draw list'

version Draw::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Describe some switch here'
switch [:s,:switch]

desc 'Describe some flag here'
default_value 'the default'
arg_name 'The name of the argument'
flag [:f,:flagname]

GUESTS = [
  {
    name: "Mr Brault",
    joint: "Mme Brault"
  },
  {
    name: "Mr Martineau",
    joint: "Mrs Martineau"
  },
  {
    name: "Mr Leon",
    joint: "Mrs Leon"
  }
]

desc 'Add a new guest to the list'
arg_name 'Describe arguments to add here'
command :add do |c|
  c.desc 'Guest Name'
  c.flag [:n, :name]
  c.desc 'Guest Spouse/Friend Name'
  c.flag [:j, :joint]

  c.action do |global_options,options,args|
    begin
      guests = []
      @store.transaction do
        guests = @store[:guests]
      end
      if guests.select {|g| g[:name].downcase.include? options[:name].downcase }.length == 0
        guest = Guest.new(options[:name], options[:joint])
        @store.transaction do
          @store[:guests] << guest
          puts "Successfully added " + guest.name + "to the list of guests" if @store[:guests].include? guest
        end
      else
        puts "Guest " + args[0] + " already exists in the list"
      end
    rescue Exception => e
      puts "Guest::add \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Exports the guests list'
command :export do |c|
  c.action do |global_options,options,args|
    begin
      buffer = []
      guests = []
      @store.transaction do
        guests = @store[:guests]
      end
      guests.each do |guest|
        buffer << "Name: #{guest.name}, Joint: #{guest.joint}}"
      end
      system "echo '#{buffer}' > guests.txt"
    rescue Exception => e
      puts "Guest::export \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Lists all family guests'
arg_name 'filtered by name'
command :list do |c|
  c.desc 'Show the guest spouse/friend name'
  c.default_value true
  c.switch [:show_joint, :s]

  c.desc 'Specify printing format of the list'
  c.default_value 'default'
  c.flag :f

  c.action do |global_options,options,args|
    begin
      keyword = args[0] unless args.nil?
      guests = []
      @store.transaction do
        guests = @store[:guests]
      end

      guests = keyword.nil? ? guests : guests.select {|g| g.name.downcase.include? keyword.downcase }
      print_all guests
    rescue Exception => e
      puts "Guest::list \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Empty guest list'
command :reset do |c|
  c.action do |global_options,options,args|
    begin
      @store.transaction do
        @store[:guests] = []
        guests = @store[:guests]
        puts "Successfullly deleted all guests" if guests.count = 0
      end
    rescue Exception => e
      puts "draw::reset \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Seed guests into the list'
command :seed do |c|
  c.action do |global_options,options,args|
    begin
      guests = GUESTS
      @store.transaction do
        guests.each do |g|
          guest = Guest.new(g[:name], g[:joint])
          @store[:guests] << guest
          puts "Successfully added " + guest.name + " to the list of guests" if @store[:guests].include? guest
        end
      end
    rescue Exception => e
      puts "Guest::seed \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Show a guest gift recipient'
arg_name 'Name of the guest'
command :show do |c|
  c.action do |global_options,options,args|
    begin
      @store.transaction do
        guests = @store[:guests]
      end

      if args
        name = args[0]
        guest = guests.select {|g| g.name.downcase.include? name.downcase }
        # puts guest.inspect
        if guest
          print_one guest[0]
        else
          puts "Could not find the guest specified"
        end
      end
    rescue Exception => e
      puts "Guest::add \t ERROR:\t #{e.message}"
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  @store = PStore.new %(#{ENV['HOME']}/draw.pstore)
  @store.transaction do
    @store[:guests] ||= []
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

private

def print_all guests
  if guests
    guests.each do |guest|
      print_one guest
    end
  else
    puts "No guests to print"
  end
end

def print_one guest
  name = guest.name ? (guest.name.color :white) : "No Name"
  joint = guest.joint ? (guest.joint.color :cyan) : ""
  puts %Q{#{name} (#{joint})}
end

exit run(ARGV)
