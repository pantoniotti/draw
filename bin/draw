#!/usr/bin/env ruby
require 'gli'

begin # XXX: Remove this begin/rescue before distributing your app

  require 'draw'
  require 'rainbow/ext/string'
  require 'highline/import'
  require 'pstore'
  require 'cucumber'
  require 'terminal-table'

rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/draw` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/draw now"
  exit 64
end

include GLI::App

program_desc 'This app lets you build a list of guests and run a gift draw from this list'

version Draw::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Guests namespace'
command :guests do |g|

  g.desc 'Add a new guest to the list'
  g.command :add do |c|
    c.desc 'Guest Name'
    c.flag [:n, :name], required: true
    c.desc 'Guest Spouse/Friend Name'
    c.flag [:j, :joint]

    c.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          guests = @store[:guests]
        end
        values = [options[:name], options[:joint]]

        add = (guests.length > 0 && guests.select {|g| g.name.downcase.include? options[:name].downcase }.length > 0) ? false : true

        if add
          guest = Guest.new(options[:name], options[:joint])
          @store.transaction do
            @store[:guests] << guest
            if @store[:guests].include? guest
              puts "Successfully added " + guest.name + " to the list of guests"
              guests << guest
            end
          end
        else
          name = options[:name].color :red
          puts "Guest '" + name + "' is already in the list"
        end
        print_table guests
      rescue Exception => e
        puts "draw::guests::add \t ERROR:\t #{e.message}"
      end
    end
  end

  g.desc 'Lists all guests'
  g.arg_name 'name'
  g.command :list do |c|
    c.desc 'Show the guest spouse/friend name'
    c.default_value true
    c.switch [:show_joint, :s]

    c.desc 'Specify printing format of the list'
    c.default_value 'default'
    c.flag :f

    c.action do |global_options,options,args|
      begin
        keyword = args[0] unless args.nil?
        guests = []
        @store.transaction do
          guests = @store[:guests]
        end

        guests = keyword.nil? ? guests : guests.select {|g| g.name.downcase.include? keyword.downcase }
        if guests.nil? || guests.length == 0
          if keyword
            puts "No guest match the query: " + keyword
          else
            puts "The list of guests is empty ..."
          end
        end
        print_table guests
      rescue Exception => e
        puts "draw::guests::list \t ERROR:\t #{e.message}"
      end
    end
  end

  g.desc 'Match all guests'
  g.command :match do |c|
    c.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          guests = @store[:guests]
        end
        guests.each do |guest|
          if guest.joint
            add = (guests.length > 0 && guests.select {|g| g.name.downcase.include? guest.joint.downcase }.length > 0) ? false : true
            if add
              new_guest = Guest.new(guest.joint, guest.name)
              @store.transaction do
                @store[:guests] << new_guest
                puts "Successfully added " + new_guest.name + " to the list of guests" if @store[:guests].include? new_guest
              end
            else
              name = guest.joint.color :red
              puts "Guest '" + name + "' is already in the list"
            end
          end
        end
        print_table guests
      rescue Exception => e
        puts "draw::guests::match \t ERROR:\t #{e.message}"
      end
    end
  end

  g.desc 'Delete all guests in the list'
  g.command :reset do |c|
    c.action do |global_options,options,args|
      begin
        guests = []
        @store.transaction do
          @store[:guests] = []
          guests = @store[:guests]
        end
        puts "Successfully deleted all guests" if guests.length == 0
        print_table guests
      rescue Exception => e
        puts "draw::guests::reset \t ERROR:\t #{e.message}"
      end
    end
  end

  g.desc 'Seed guests list'
  g.command :seed do |c|
    c.action do |global_options,options,args|
      begin
        # new_guests = GUESTS
        new_guests = load_seed()
        @store.transaction do
          guests = @store[:guests]
          new_guests.each do |new_guest|
            if guests.length > 0 && guests.select {|g| g.name.downcase.include? new_guest[0].downcase }.length == 0
              guest = Guest.new(new_guest[0], new_guest[1])
              @store[:guests] << guest
              puts "Successfully added " + guest.name + " to the list of guests" if @store[:guests].include? guest
            else
              name = new_guest[0].color :red
              puts "Guest '" + name + "' is already in the list"
            end
          end
        end
      rescue Exception => e
        puts "draw::guests::seed \t ERROR:\t #{e.message}"
      end
    end
  end

end

desc 'Run the draw and display gifts recipients names in the guests list'
command :run do |c|
  c.action do |global_options,options,args|
    begin
      guests = []
      @store.transaction do
        guests = @store[:guests]
      end
      # Make sure we have all guests listed
      if guests
        recipients = guests.map { |g| g.name }
        guests.each do |guest|
          recipient = guest.name
          while recipients.count > 0 && (guest.name == recipient || guest.joint == recipient)
            recipient = recipients.shuffle.sample
          end
          guest.recipient = recipient + " -> OK"
          # Remove recipient from recipients array
          recipients.reject! {|x| x == recipient }
        end
        @store.transaction do
          @store[:guests] = guests
        end
      else
        puts "The list of guests is empty ..."
      end
      print_table guests
    rescue Exception => e
      puts "draw::run \t ERROR:\t #{e.message}"
    end
  end
end

desc 'Reinitialize the recipient column in the guests list'
command :init do |c|
  c.action do |global_options,options,args|
    begin
      guests = []
      @store.transaction do
        guests = @store[:guests]
      end
      if guests
        guests.each do |guest|
          guest.recipient = nil
        end
        print_table guests
      else
        puts "The list of guests is empty ..."
      end
    rescue Exception => e
      puts "draw::init \t ERROR:\t #{e.message}"
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  @store = PStore.new %(#{ENV['HOME']}/draw.pstore)
  @store.transaction do
    @store[:guests] ||= []
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

private

def print_all guests
  guests.each do |guest|
    print_one guest
  end
end

def print_one guest
  name = guest.name ? (guest.name.color :white) : "No Name"
  joint = guest.joint ? (guest.joint.color :cyan) : ""
  puts %Q{#{name} (#{joint})}
end

def print_table guests
  table = Terminal::Table.new do |t|
    t.style = { width: 80, border_x: "=", border_i: "+"}
    t.title = "Draw list of guests"
    t.headings = ["Index", "Guest", "Spouse/Friend", "Gift Recipient"]

    index = 1
    guests.each_with_index do |guest, index|
      index += 1
      t << [index.to_s, guest.name, guest.joint, guest.recipient]
    end
  end
  table.align_column 0, :center
  puts table
end

def load_seed
  guests = []
  line_num = 0
  text = File.open('guests.txt').read
  text.gsub!(/\r\n?/, "\n")
  text.each_line do |line|
    values = line.split(",")
    guests << [values[0].strip(), values[1].strip()]
  end
  return guests
end

exit run(ARGV)
